Mardi : * Commencement de printf.
        * Création du Makefile.
        * Fondation de la fonction printf, bonne base pour la suite.
Dans la fonction printf il y a une boucle qui lit la chaine de caractère.
Tant que le caractère '%' n'est pas rencontré, écrire ce dernier dans la sortie
standard. Lorsqu'un '%' est rencontré, accéder au parsing. Dans le parsing
regarder de quel spécifieur il s'agit. Une fois le spécifieur détecté, accéder
a la fonction qui récupère l'argument et affiche ce qu'il doit être transformé.

Tant que string existe
{
    si string[i] == '%'
        i++;
        parsing
    else
        write(1, string[i], 1);
        i++;
        compteur de lettre + 1
}

parsing
{
    si string[i] == 'c'
        accéder à ma fonction qui récupère l'argument.
    si string[i] == '...'
        accéder à ma fonction qui récup l'argument ...

...
}

fonction qui récupère l'argument 'c'
{
    je récupère l'argument = va_arg(ap, int);
    j'augmente mon i de 1;
    j'affiche le contenu de "je récupère l'argument".
    j'augmente mon compteur de lettre de 1.
}

mon code est propre structuré et organisé.

Objectif :

- Mercredi  : * Implémenter un autre spécifieur. Disons : %
- Jeudi     : * Implémenter : s
- Vendredi  : * Implémenter : p
- Samedi    : * Implémenter : di
- Dimanche  : * Implémenter : u

- Lundi     : * Implémenter : xX
- Mardi     : * Implémenter : .précision
- Mercredi  : * Implémenter : largeur
- Jeudi     : * Implémenter : * / 0 / -
- Vendredi  : * Gestion des cas particuliers.

Semaine suivante : Peaufiner printf.

Mon projet doit avoir au minimum 1 push par jour.

Liens utiles :  google -> limits.h microsoft
                google -> printf cplusplus





------------------------------------------------------------------

TYPES : cspdiuxX%

FLAGS : -0.*

LA PRECISION AGIT SUR LES CARACTERES / CHIFFRES A PRINT
LA WIDTH AGIT SUR LA TAILLE DE CHAMP 
(Ex : %15.2s", "lolo" => '              lo'%

Cas générique de la width : 
Minimum de caractères a print, si la valeur de width est superieure a la len de ce que j'ai a print, je comble le reste par des espaces (a droite par défaut, a gauche si j'ai la presence d'un moins -> le flag - n'agit qu'avec la width, si - tout seul, je ne print pas + le - n'agit pas si champ < strlen de ce que j'ai a print)
(Ex : ("%-10.30d\n", 123456789) => 000000000000000000000123456789)
("%-30.30s\n", "123456789") => 123456789                     $
("%5.d\n", 123456789) => 123456789$

Cas générique de la précision :
Pour d, i, u, x, X precise le minimum de chiffres a écrire 
Si le nombre de chiffres a print est plus petit que precision, on complete de zero DEVANT
(Ex : ("%.15d", 1234) => 000000000001234)
Si la precision est plus petite, on ne tronque pas la valeur a print
(Ex : ("%.2d", 1234) => 1234)
Si precision de .0, alors 0 devant n'est pas print pour le cas 0
(ex : 0, 01... != 105 sera print 105)

Pour s, precise le maximum de caractères a print
Si precision < strlen(str)
	cut jusqu'a [atoi de precision] premiers octets
Autrement elle n'influe pas ma valeur a print

Cas générique de l'étoile : récupère dans l'ordre dans les arguments


Pour le char :
Width existante donc - aussi, pas de precision

TO DO :

Nouvelle structure avec mes variables outils
Check de ma structure avec variables inutiles

Finir l'implementation de C avec width et flag -
'\0'

Cas de rencontre precision et width
Implementation de la precision pour s avant de gérer la width
Passage de spec sur convert char et precision